#!/usr/bin/env python

#check and load depedencies
#sys,os thats normal
#yaml for config parsing
#ftplib FTP/S support
#subprocess run CMD
ok = True
depedencies = ['sys','os','yaml','ftplib','subprocess']
for dep in depedencies:
  try:
    vars()[dep] = __import__(dep)
  except ImportError:
    ok = False
    print ('Python Module "%s" not found, please install "python-%s"' % (dep,dep))

#TODO implement this into depedencies
from urllib.parse import urlparse


class deployer:
  def __init__(self):
    #Set config file name
    self.config_file = 'deploy.yml'
    if 1 in sys.argv:
      self.config_file = sys.argv[1];

    ok = True
    #read config file
    if ok:
      ok = self.read_config()

    #sync what we get
    if ok:
      ok = self.sync()

  def read_config(self):
    if os.path.isfile(self.config_file)!=True:
      print ("Failed to parse configuration file, %s exists ?" % (self.config_file))
      return False
    else:
      f = open(self.config_file)
      config = yaml.load(f)
      f.close()

      self.config = {}

      for i in config:
        cfg = urlparse(i)
        #config set from parsed URL and default values
        self.config[i] = {'scheme':cfg.scheme,'host':cfg.hostname,'port':cfg.port,'path':cfg.path,'user':cfg.username,'password':cfg.password,'time_out':10,'revision_file':'REVISION','branch': 'MASTER'}

        #set additional values
        for c in config[i]:
          self.config[i][c] = config[i][c]
      return True


  def sync(self):
    #git test remove me
    git = GIT()
    #print (git.get_revision())
    #print (git.diff_uncommitted())
    #print (git.diff_comitted())
    root = git.get_root_dir()
    if os.path.exists(root):
      for x in self.config:
        if self.config[x]['skip'] == False:
          if self.config[x]['scheme'] == 'sftp':
            connection = SFTP(self.config[x])
          elif self.config[x]['scheme'] == 'ftps':
            connection = FTPS(self.config[x])
          elif self.config[x]['scheme'] == 'ftp':
            connection = FTP(self.config[x])
          else:
            print ('Unknow scheme, please use sftp/ftps/ftp ')

          remote_rev = connection.read_file(self.config[x]['path'],self.config[x]['revision_file'])
          if remote_rev == git.get_revision():
            print ('revisions match, skiping deploy')
          else:
            print ('revisions dont match')
            files = git.diff_comitted(remote_rev)
            for u in files['upload']:
              print ("Deploying " + root + '/' + u)
              connection.upload_file(root,self.config[x]['path'],u)
              print ("Deployed!")

            for d in files['delete']:
              print ('D' + d)
    else:
      print ('I was unable to get git root dir!')


#**********************************************************************************************************************
#This class handle SFTP (SSH) connections
#This truly sux cos PARAMICO is not suported in py 3 i must implement this by simple cmd commands (Only usable on UNIX)
#**********************************************************************************************************************
class SFTP:
  #TODO Implement port set!
  def read_file(self,path,filename):
    if 'port' not in config:
      config['port'] = 22
    return subprocess.check_output(['ssh', config['user'] + ':' + config['password'] + '@' + config['host'], 'cat ' + path + filename]).decode('utf8').strip()

  def upload_file(self,pathf,patht,filename):
    if 'port' not in config:
      config['port'] = 22
    return subprocess.check_output(['scp', '-P ' + config['port'], pathf + filename, config['user'] + ':' + config['password'] + '@' + config['host'] + ':' + patht]).decode('utf8').strip()


#*********************************
#This class handle FTP connections
#@TODO Check if is posible to use absolute paths on FTP, i dont like solution with cwd and relative path to that dir
#*********************************
class FTP:

  """
  FTP/S class init
  @param config, config of deployer
  """
  def __init__(self,config):
    self.conn = ftplib.FTP()
    self.conn.connect(config['host'],config['port'],config['time_out'])

    if config['user']:
      self.conn.login(config['user'],config['password'])
    print (self.conn.getwelcome())

  """
  Method reads file on FTP
  @param path path to file
  @param filename name of file to read
  @todo rewrite to use absolute paths
  """
  def read_file(self,path,filename):
    self.conn.cwd(path)
    self.downloaded_data = ''
    try:
      self.conn.retrbinary("RETR " + filename, self.downloaded)
      return self.downloaded_data.strip()
    except Exception as inst:
      return ''

  """
  Method is used as download handler for read_file method
  @param data data recived
  """
  def downloaded(self,data):
    self.downloaded_data += data.decode('utf8')

  """
  Method uploads file on FTP
  @param pathf path to file on local filesystem
  @param patht path to file on remove filesystem
  @param filename name of file relative to GIT root dir
  """
  def upload_file(self,pathf,patht,filename):
    self.conn.cwd(patht)
    self.create_path(os.path.dirname(patht +filename))
    self.conn.cwd(patht)
    f = open(pathf + '/' + filename, "rb")
    self.conn.storbinary('STOR ' + filename, f)
    f.close()

  """
  Method creates path on FTP, path must be absolute to HTP root!
  @param path path to create eg.: /libs/test.php where first / is root of FTP
  """
  def create_path(self,path):
    splited = path.strip('/').split('/')
    prev = ''
    for i in splited:
      if prev:
        prev += '/' + i
      else:
        prev = i

      if prev:
        if self.directory_exists(prev) is False:
          self.conn.mkd(prev)

  """
  Method checks if directory exists
  @param dir dirpath to check
  """
  def directory_exists(self,dir):
    exists = True
    try:
      self.conn.cwd(dir)
    except:
      exists = False

    #if exists that means we successfully cwd dir, so we need reset position to root
    if exists:
      self.conn.cwd('/')

    return exists

#**********************************
#This class handle FTPS connections
#**********************************
class FTPS:
  def __init__(self,config):
    self.conn = ftplib.FTP_TLS()
    self.conn.connect(config['host'],config['port'],config['time_out'])

    if config['user']:
      self.conn.login(config['user'],config['password'])

    print (self.conn.getwelcome())

  def read_file(self,path,filename):
    self.conn.cwd(path)
    self.downloaded_data = ''
    self.conn.retrbinary("RETR " + filename, self.downloaded)

    return self.downloaded_data.strip()

  def downloaded(self,data):
    self.downloaded_data += data.decode('utf8')

  def upload_file(self,pathf,patht,filename):
    self.conn.cwd(patht)
    f = open(pathf + filename, "rb")
    self.conn.storbinary('STOR ' + filename, f)
    f.close()

#*****************************************
#Class implementing fetching data from GIT
#*****************************************
class GIT:
  #Method return current GIT revision
  def get_revision(self):
    return subprocess.check_output(['git','rev-parse', 'HEAD']).decode('utf8').strip()

  #Method return uncommited files list
  def diff_uncommitted(self):
    mixed = subprocess.check_output(['git', 'diff', '--name-status']).decode('utf8').strip()
    mixed += subprocess.check_output(['git', 'diff', '--cached', '--name-status']).decode('utf8').strip()
    return self.parse_files(mixed)

  #Method return commited files list
  #@param path
  #@param revision
  def diff_comitted(self, revision = ''):
    if revision:
      files = subprocess.check_output(['git', 'diff', '--name-status', revision]).decode('utf8').strip()
    else:
      filesall = subprocess.check_output(['git', 'ls-files',self.get_root_dir(),'--full-name']).decode('utf8').strip().split("\n")
      files = ''
      #make same list as git diff returns, so i can parse it by normal parser
      for i in filesall:
        files += 'M	' + i + "\n"
    return self.parse_files(files)

  #Method parses GIT diff output into filelist
  #@param files output from GIT diff
  #@return dict upload = files to upload, delete = files to delete
  def parse_files(self,files):
    changes = {'upload':[],'delete':[]}
    #ignore these files
    ignore = ['.gitignore']
    for f in files.split("\n"):
      if f.strip():
        fileinfo = f.split('	')
        action = fileinfo[0].strip()
        filepath = fileinfo[1].strip()

        if os.path.basename(filepath) not in ignore:
          if action in ['A', 'M', 'C']:
            changes['upload'].append(filepath)
          elif action == 'D':
            changes['delete'].append(filepath)
    return changes

  #Method returns GIT root directory
  #@return str path
  def get_root_dir(self):
    return subprocess.check_output(['git', 'rev-parse', '--show-toplevel']).decode('utf8').strip()


#rock 'n' roll
if __name__ == "__main__":
  if ok:
      deployer = deployer()
  #try:
  #  if ok:
  #    deployer = deployer()
  #  else:
  #    print ('Exiting...')
  #except Exception as inst:
  #  print (str(inst))
