#!/usr/bin/env python

"""
check and load depedencies
sys,os thats normal
yaml for config parsing
ftplib FTP/S support
subprocess run CMDs
"""
ok = True
depedencies = ['sys','os','yaml','ftplib','subprocess','io']
for dep in depedencies:
  try:
    vars()[dep] = __import__(dep)
  except ImportError:
    ok = False
    print ('Python Module "%s" not found, please install "python-%s"' % (dep,dep))

#TODO implement this into depedencies
from urllib.parse import urlparse

#***********************************************
#This class performing deploying on our target/s
#***********************************************
class deployer:
  def __init__(self):
    #Set config file name
    self.config_file = 'deploy.yml'
    if 1 in sys.argv:
      self.config_file = sys.argv[1];

    ok = True
    #read config file
    if ok:
      ok = self.read_config()

    #sync what we get
    if ok:
      ok = self.sync()

  def read_config(self):
    if os.path.isfile(self.config_file)!=True:
      print ("Failed to parse configuration file, %s exists ?" % (self.config_file))
      return False
    else:
      f = open(self.config_file)
      config = yaml.load(f)
      f.close()

      self.config = {}

      for i in config:
        cfg = urlparse(i)
        #config set from parsed URL and default values
        self.config[i] = {'scheme':cfg.scheme,'host':cfg.hostname,'port':cfg.port,'path':cfg.path,'user':cfg.username,'password':cfg.password,'time_out':10,'revision_file':'REVISION','branch': 'MASTER'}

        #set additional values
        for c in config[i]:
          self.config[i][c] = config[i][c]
      return True

  #@TODO pass config only in constructor, so remove it from read_file adn upload_file etc
  def sync(self):
    git = GIT()
    root = git.get_root_dir()
    if os.path.exists(root):
      for x in self.config:
        if self.config[x]['skip'] == False:
          if self.config[x]['scheme'] == 'sftp':
            connection = SFTP(self.config[x])
          elif self.config[x]['scheme'] == 'ftps' or self.config[x]['scheme'] == 'ftp':
            connection = FTP(self.config[x])
          else:
            print ('Unknow scheme, please use sftp/ftps/ftp ')

          remote_rev = connection.read_file(self.config[x]['path'],self.config[x]['revision_file'])
          local_rev = git.get_revision()
          if remote_rev == local_rev:
            print ('Revisions match, skiping deploy on ' + self.config[x]['host'])
          else:
            print ('Revisions not match, deploying on ' + self.config[x]['host'])
            files = git.diff_comitted(remote_rev)

            #upload new/edited files to FTP
            for u in files['upload']:
              print ("Deploying " + root + '/' + u + ' --> ' + self.config[x]['path'] + u)
              connection.upload_file(root,self.config[x]['path'],u)

            #delete deleted files on FTP
            for d in files['delete']:
              print ("Deleting " + self.config[x]['path'] + d)


          #deploy revision file
          connection.upload_string(self.config[x]['path'],self.config[x]['revision_file'],local_rev)
    else:
      print ('I was unable to get git root dir!')


#**********************************************************************************************************************
#This class handle SFTP (SSH) connections
#This truly sux cos PARAMICO is not suported in py 3 i must implement this by simple cmd commands (Only usable on UNIX)
#**********************************************************************************************************************
class SFTP:
  #TODO Implement port set!
  def read_file(self,path,filename):
    if 'port' not in config:
      config['port'] = 22
    return subprocess.check_output(['ssh', config['user'] + ':' + config['password'] + '@' + config['host'], 'cat ' + path + filename]).decode('utf8').strip()

  def upload_file(self,pathf,patht,filename):
    if 'port' not in config:
      config['port'] = 22
    return subprocess.check_output(['scp', '-P ' + config['port'], pathf + filename, config['user'] + ':' + config['password'] + '@' + config['host'] + ':' + patht]).decode('utf8').strip()


#*********************************
#This class handle FTP connections
#@TODO Check if is posible to use absolute paths on FTP, i dont like solution with cwd and relative path to that dir
#*********************************
class FTP:

  """
  FTP/S class init
  @param config, config of deployer
  """
  def __init__(self,config):
    self.config = config;
    if self.config['scheme'] == 'ftp':
      self.conn = ftplib.FTP()
    elif self.config['scheme'] == 'ftps':
      self.conn = ftplib.FTP_TLS()

    self.conn.connect(self.config['host'],self.config['port'],self.config['time_out'])

    if self.config['user']:
      self.conn.login(self.config['user'],self.config['password'])

  """
  Method reads file on FTP
  @param path path to file
  @param filename name of file to read
  @todo rewrite to use absolute paths
  """
  def read_file(self,path,filename):
    self.conn.cwd(path)
    self.downloaded_data = ''
    try:
      self.conn.retrbinary("RETR " + filename, self.downloaded)
      return self.downloaded_data.strip()
    except Exception as inst:
      return ''

  """
  Method is used as download handler for read_file method
  @param data data recived
  """
  def downloaded(self,data):
    self.downloaded_data += data.decode('utf8')

  """
  Method uploads file on FTP
  @param pathf path to file on local filesystem
  @param patht path to file on remote filesystem
  @param filename name of file relative to GIT root dir
  @todo only absolute path for file as param?
  """
  def upload_file(self,pathf,patht,filename):
    self.create_path(os.path.dirname(patht + filename))
    f = open(pathf + '/' + filename, "rb")
    self.conn.storbinary('STOR ' + filename, f)
    f.close()

  """
  Method uploads string on FTP
  @param patht path to file on remote filesystem
  @param filename name of file relative to GIT root dir
  @todo only absolute path for file as param?
  """
  def upload_string(self,patht,filename,data):
    self.create_path(os.path.dirname(patht + filename))
    f = io.BytesIO(bytes(data,'utf8'))
    self.conn.storbinary('STOR ' + filename, f)
    f.close()


  """
  Method creates path on FTP, path must be absolute to HTP root!
  @param path path to create eg.: /libs/test.php where first / is root of FTP
  """
  def create_path(self,path):
    splited = path.strip('/').split('/')
    prev = ''
    for i in splited:
      if prev:
        prev += '/' + i
      else:
        prev = i

      if prev:
        if self.directory_exists(prev) is False:
          self.conn.mkd(prev)

  """
  Method checks if directory exists
  @param dir dirpath to check
  """
  def directory_exists(self,dir):
    exists = True
    try:
      self.conn.cwd(dir)
    except:
      exists = False

    #if exists that means we successfully cwd dir, so we need reset position to root
    if exists:
      self.conn.cwd(self.config['path'])

    return exists

#*****************************************
#Class implementing fetching data from GIT
#*****************************************
class GIT:
  """
  Method return current GIT revision
  @return git revision
  """
  def get_revision(self):
    return subprocess.check_output(['git','rev-parse', 'HEAD']).decode('utf8').strip()

  """
  Method return uncommited files list
  @return uncommitted files list
  """
  def diff_uncommitted(self):
    mixed = subprocess.check_output(['git', 'diff', '--name-status']).decode('utf8').strip()
    mixed += subprocess.check_output(['git', 'diff', '--cached', '--name-status']).decode('utf8').strip()
    return self.parse_files(mixed)

  """
  Method return commited files list
  @param path
  @param revision
  """
  def diff_comitted(self, revision = ''):
    if revision:
      files = subprocess.check_output(['git', 'diff', '--name-status', revision]).decode('utf8').strip()
    else:
      filesall = subprocess.check_output(['git', 'ls-files',self.get_root_dir(),'--full-name']).decode('utf8').strip().split("\n")
      files = ''
      #make same list as git diff returns, so i can parse it by normal parser
      for i in filesall:
        files += 'M	' + i + "\n"
    return self.parse_files(files)

  """
  Method parses GIT diff output into filelist
  @param files output from GIT diff
  @return dict upload = files to upload, delete = files to delete
  """
  def parse_files(self,files):
    changes = {'upload':[],'delete':[]}
    #ignore these files
    ignore = ['.gitignore']
    for f in files.split("\n"):
      if f.strip():
        fileinfo = f.split('	')
        action = fileinfo[0].strip()
        filepath = fileinfo[1].strip()

        if os.path.basename(filepath) not in ignore:
          if action in ['A', 'M', 'C']:
            changes['upload'].append(filepath)
          elif action == 'D':
            changes['delete'].append(filepath)
    return changes

  """
  Method returns GIT root directory
  @return str path
  """
  def get_root_dir(self):
    return subprocess.check_output(['git', 'rev-parse', '--show-toplevel']).decode('utf8').strip()


#rock 'n' roll
if __name__ == "__main__":
  if ok:
      deployer = deployer()
  #try:
  #  if ok:
  #    deployer = deployer()
  #  else:
  #    print ('Exiting...')
  #except Exception as inst:
  #  print (str(inst))
