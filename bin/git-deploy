#!/usr/bin/env python

"""
check and load depedencies
sys,os thats normal
yaml for config parsing
ftplib FTP/S support
subprocess run CMDs
"""
ok = True
depedencies = ['sys','os','yaml','ftplib','subprocess','io']
for dep in depedencies:
  try:
    vars()[dep] = __import__(dep)
  except ImportError:
    ok = False
    print ('Python Module "%s" not found, please install "python-%s"' % (dep,dep))

#TODO implement this into depedencies
from urllib.parse import urlparse

#***********************************************
#This class performing deploying on our target/s
#***********************************************
class deployer:
  def __init__(self):
    #Set config file name
    self.config_file = 'deploy.yml'
    if 1 in sys.argv:
      self.config_file = sys.argv[1];

    ok = True
    #read config file
    if ok:
      ok = self.read_config()

    #sync what we get
    if ok:
      ok = self.sync()

  def read_config(self):
    if os.path.isfile(self.config_file)!=True:
      print ("Failed to parse configuration file, %s exists ?" % (self.config_file))
      return False
    else:
      f = open(self.config_file)
      config = yaml.load(f)
      f.close()

      self.config = {}

      for i in config:
        cfg = urlparse(i)
        #config set from parsed URL and default values
        self.config[i] = {'scheme':cfg.scheme,'host':cfg.hostname,'port':cfg.port,'path':cfg.path,'user':cfg.username,'password':cfg.password,'overwrite_if_same_revision': False,'time_out':10,'revision_file':'REVISION','branch': 'MASTER'}

        #set additional values
        for c in config[i]:
          self.config[i][c] = config[i][c]
      return True

  def sync(self):
    git = GIT()
    root = git.get_root_dir()
    if os.path.exists(root):
      for x in self.config:
        if self.config[x]['skip'] == False:
          if self.config[x]['scheme'] == 'sftp':
            connection = SFTP(self.config[x])
          elif self.config[x]['scheme'] == 'ftps' or self.config[x]['scheme'] == 'ftp':
            connection = FTP(self.config[x])
          else:
            print ('Unknow scheme, please use sftp/ftps/ftp ')

          #We dont need check revision at all
          if self.config[x]['overwrite_if_same_revision'] is False:
            remote_rev = connection.read_file(self.config[x]['revision_file']).decode('utf8').strip()
          else:
            remote_rev = ''

          local_rev = git.get_revision()

          if remote_rev == local_rev:
            print ('Revisions match, skiping deploy on ' + self.config[x]['host'])
          else:
            print ('Revisions not match, deploying on ' + self.config[x]['host'])
            files = git.diff_comitted(remote_rev)

            #upload new/edited files to FTP
            for u in files['upload']:
              connection.upload_file(root + u,u)

            #delete deleted files on FTP
            for d in files['delete']:
              connection.delete(d)

            #deploy new revision file
            connection.upload_string(self.config[x]['revision_file'],local_rev)
            print ("Deploying done!")

    else:
      print ('I was unable to get GIT root dir!')


#**********************************************************************************************************************
#This class handle SFTP (SSH) connections
#This truly sux cos PARAMICO is not suported in py 3 i must implement this by simple cmd commands (Only usable on UNIX)
#**********************************************************************************************************************
class SFTP:

  def __init__(self,config):
    self.config = config
    if 'port' not in self.config:
      self.config['port'] = 22

  def read_file(self,filename):
    command = ['ssh']
    command.append('-p ' + str(self.config['port']))

    if self.config['password']:
      command.append(self.config['user'] + ':' + self.config['password'] + '@' + self.config['host'])
    else:
      command.append(self.config['user'] + '@' + self.config['host'])

      command.append('cat ' + self.path(filename))

    return subprocess.check_output(command).strip()

  def upload_file(self,pathf,patht):
    patht = self.path(patht)
    print ("Deploying " + pathf + ' --> ' + patht)

    command = ['scp']
    command.append('-P ' + str(self.config['port']))
    command.append(pathf)

    if self.config['password']:
      command.append(self.config['user'] + ':' + self.config['password'] + '@' + self.config['host'] + ':' + patht)
    else:
      command.append(self.config['user'] + '@' + self.config['host'] + ':' + patht)

    return subprocess.check_output(command).decode('utf8').strip()

  def upload_string(self,patht,data):
    patht = self.path(patht)
    command = ['ssh']
    command.append('-p ' + str(self.config['port']))

    if self.config['password']:
      command.append(self.config['user'] + ':' + self.config['password'] + '@' + self.config['host'])
    else:
      command.append(self.config['user'] + '@' + self.config['host'])

    command.append('cat > %s' % patht)

    subprocess.Popen(command,stdin=subprocess.PIPE).communicate(bytes(data,'utf8'))

  def delete(self,path):
    command = ['ssh']
    command.append('-p ' + str(self.config['port']))

    if self.config['password']:
      command.append(self.config['user'] + ':' + self.config['password'] + '@' + self.config['host'])
    else:
      command.append(self.config['user'] + '@' + self.config['host'])

      command.append('rm "' + self.path(path) + '"')

    return subprocess.check_output(command).strip()

  def path(self,path_on_remote = '/'):
    return os.path.join(self.config['path'],path_on_remote.lstrip('/'))



#*********************************
#This class handle FTP connections
#*********************************
class FTP:

  """
  FTP/S class init
  @param config, config of deployer
  """
  def __init__(self,config):
    self.config = config;
    if self.config['scheme'] == 'ftp':
      self.conn = ftplib.FTP()
    elif self.config['scheme'] == 'ftps':
      self.conn = ftplib.FTP_TLS()

    self.conn.connect(self.config['host'],self.config['port'],self.config['time_out'])

    if self.config['user']:
      self.conn.login(self.config['user'],self.config['password'])

    #here i get FTP root
    self.ftp_root = self.conn.pwd()

  """
  Method reads file on FTP
  @param path path to file
  @param filename name of file to read
  """
  def read_file(self,filename):
    downloaded_data =  io.BytesIO()
    try:
      self.conn.retrbinary("RETR " + self.path(filename), downloaded_data.write)
      return downloaded_data.getvalue()
    except:
      return b''

  """
  Method uploads file on FTP
  @param pathf path to file on local filesystem
  @param patht path to file on remote filesystem
  """
  def upload_file(self,pathf,patht):
    patht = self.path(patht)
    print ("Deploying " + pathf + ' --> ' + patht)
    self.create_path(os.path.dirname(patht))
    f = open(pathf, "rb")
    self.conn.storbinary('STOR ' + patht, f)
    f.close()

  """
  Method uploads string on FTP
  @param patht path to file on remote filesystem
  @param data data to upload
  """
  def upload_string(self,patht,data):
    patht = self.path(patht)
    self.create_path(os.path.dirname(patht))
    f = io.BytesIO(bytes(data,'utf8'))
    self.conn.storbinary('STOR ' + patht, f)
    f.close()


  """
  Method creates path on FTP, path must be absolute to FTP root!
  @param path path to create eg.: /libs/test.php where first / is root of FTP
  """
  def create_path(self,path):
    splited = path.strip('/').split('/')
    prev = ''
    for i in splited:
        prev += '/' + i

        #i need check paths only under FTP root and specified path
        if self.path().find(prev) == -1:
          if self.directory_exists(prev) is False:
            self.conn.mkd(prev)

  """
  Method checks if directory exists
  @param dir dirpath to check
  """
  def directory_exists(self,dir):
    exists = True
    try:
      self.conn.cwd(dir)
    except:
      exists = False

    #if exists that means we successfully cwd dir, so we need reset position to root
    if exists:
      self.conn.cwd(self.path())
    return exists

  """
  Method deletes file on FTP
  @param path path to file to delete
  @todo implement tree deleting somehow
  """
  def delete(self,path):
    path = self.path(path)
    print ("Deleting " +  path)
    self.conn.delete(path)

  def path(self,path_on_ftp = '/'):
    return os.path.join(self.ftp_root,self.config['path'].lstrip('/'),path_on_ftp.lstrip('/'))


#*****************************************
#Class implementing fetching data from GIT
#*****************************************
class GIT:
  """
  Method return current GIT revision
  @return git revision
  """
  def get_revision(self):
    return subprocess.check_output(['git','rev-parse', 'HEAD']).decode('utf8').strip()

  """
  Method return uncommited files list
  @return uncommitted files list
  """
  def diff_uncommitted(self):
    mixed = subprocess.check_output(['git', 'diff', '--name-status']).decode('utf8').strip()
    mixed += subprocess.check_output(['git', 'diff', '--cached', '--name-status']).decode('utf8').strip()
    return self.parse_files(mixed)

  """
  Method return commited files list
  @param path
  @param revision
  """
  def diff_comitted(self, revision = ''):
    if revision:
      files = subprocess.check_output(['git', 'diff', '--name-status', revision]).decode('utf8').strip()
    else:
      filesall = subprocess.check_output(['git', 'ls-files',self.get_root_dir(),'--full-name']).decode('utf8').strip().split("\n")
      files = ''
      #make same list as git diff returns, so i can parse it by normal parser
      for i in filesall:
        files += 'M	' + i + "\n"
    return self.parse_files(files)

  """
  Method parses GIT diff output into filelist
  @param files output from GIT diff
  @return dict upload = files to upload, delete = files to delete
  """
  def parse_files(self,files):
    changes = {'upload':[],'delete':[]}
    #ignore these files
    ignore = ['.gitignore']
    for f in files.split("\n"):
      if f.strip():
        fileinfo = f.split('	')
        action = fileinfo[0].strip()
        filepath = fileinfo[1].strip()

        if os.path.basename(filepath) not in ignore:
          if action in ['A', 'M', 'C']:
            changes['upload'].append(filepath)
          elif action == 'D':
            changes['delete'].append(filepath)
    return changes

  """
  Method returns GIT root directory
  @return str path
  """
  def get_root_dir(self):
    return subprocess.check_output(['git', 'rev-parse', '--show-toplevel']).decode('utf8').strip() + '/'


#rock 'n' roll
if __name__ == "__main__":
  try:
    if ok:
      deployer = deployer()
    else:
      print ('Exiting...')
  except Exception as inst:
    print (str(inst))
